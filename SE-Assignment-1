# SE-Assignment-1

Assignment: Introduction to Software Engineering Instructions: 
Answer the following questions based on your understanding of software engineering concepts. 
Provide detailed explanations and examples where appropriate.

1. Define Software Engineering:
What is software engineering, and how does it differ from traditional programming?
	Software engineering is an engineering discipline that is concerned with all aspects of software production from initial conception to
operation and maintenance.Software engineering is not just concerned with the technical processes of software development. It also includes activities
such as software project management and the development of tools, methods,and theories to support software development. In its engineering aspect software 
engineers apply theories, methods, and tools where these are appropriate. However, they use them selectively and always try to discover solutions to 
problems even when there are no applicable theories and methods. Software engineers also recognize that they must work within organizational and 
financial constraints, and they must look for solutions within these constraints.

2.  Software Development Life Cycle (SDLC):
Explain the various phases of the Software Development Life Cycle. 
	Software Development Life Cycle (SDLC): A Software Development Life Cycle or SDLC model is a simplified representation of a software process. 
It is a process used by the software industry to design, develop and test high quality software. Each process model represents a process from a
particular perspective and thus only provides partial information about that process.It consists of a detailed plan describing how to develop, 
maintain,replace and alter or enhance specific software. 

Provide a brief description of each phase.
	Phase 1: Planning and Requirement Analysis - Requirement analysis is the most important and fundamental stage in SDLC. It is performed by 
the senior members of the team with inputs from the customer, the sales department, market surveys and domain experts in
the industry. This information is then used to plan the basic project approach and to conduct product feasibility study in the economical,operational 
and technical areas.Planning for the quality assurance requirements and identification of the risks associated with the project is also done in the planning stage. 
The outcome of the technical feasibility study is to define the various technical approaches that can be followed to implement the project 
successfully with minimum risks.

	Phase 2: Defining Requirements - the next step is to clearly define and document the product requirements and get them approved from
the customer or the market analysts and it is done through an SRS (Software Requirement Specification) document which consists of all the product
requirements to be designed and developed during the project life cycle.

	Phase 3: Designing the Product Architecture - The Design phase is all about building the framework. The development team is responsible 
for software engineering and outlines the software’s functionality and aesthetic. This ultimately results in the software product.
The emphasis lies on outlining the software’s structure, navigation, user interfaces, and database design. This phase ensures that the software 
is user-friendly and performs its tasks efficiently.Software Requirement Specification (SRS) is the reference for product architects to come out with the 
best architecture for the product to be developed. Based on the requirements specified in SRS,usually more than one design approach for the product
architecture is proposed and documented in a DDS - Design Document Specification. This DDS is reviewed by all the important stakeholders and based 
on various parameters as risk assessment, product robustness, design modularity, budget and time constraints, the best design approach is selected for the product.
A design approach clearly defines all the architectural modules of the product along with its communication and data flow representation with the external and
third party modules (if any). The internal design of all the modules of the proposed architecture should be clearly defined with the smallest
of the details in DDS. 
The Design phase is the link between the software’s purpose (established in the Planning and Requirements Analysis phases) and its execution 
(defined in the coding or the building the product phase). It’s an essential step in creating software that works efficiently and provides an excellent user experience.

	Phase 4: Building or Developing the Product - In this phase of SDLC the actual development starts and the product is built. The programming 
code is generated as per DDS during this stage. If the design is performed in a detailed and organized manner, code generation can be accomplished 
without much hassle. Another key aspect of this phase is regular code reviews. Team members carefully examine each other’s work to identify any bugs or inconsistencies.
These meticulous assessments uphold high code standards, ensuring the software’s reliability and robustness. This phase also includes preliminary internal testing to 
confirm the software’s basic functionality.
Developers must follow the coding guidelines defined by their organization and programming tools like compilers, interpreters, debuggers, etc. are used to
generate the code. Different high level programming languages such as C, C++, Pascal, Java and PHP are used for coding. 
The programming language is chosen with respect to the type of software being developed.

	Phase 5: Testing the Product - This phase is usually a subset of all the stages as in the modern SDLC models, the testing activities are mostly involved in all the stages of
SDLC.However, this stage refers to the testing only stage of the product where product defects are reported, tracked, fixed and retested, until
the product reaches the quality standards defined in the SRS.Software testing involves a thorough examination of the software for any bugs or 
glitches that might have slipped through during coding. The aim is to ensure flawless software operation before it reaches the end-users and even identify opportunities for enhancement.
The testing process begins by setting clear parameters in line with the software’s requirements. This includes identifying the necessary software conditions, 
and outlining diverse scenarios to examine these conditions. This phase aids in creating an efficient testing strategy.

	Phase 6: Deployment in the Market and Maintenance - After crafting a product with precision, it’s time to present it to the users by pushing to the production environment. 
The Deployment phase involves rolling out the meticulously tested and fine-tuned software to its end-users.Sometimes product deployment
happens in stages as per the business strategy of that organization. The product may first be released in a limited segment and tested in the
real business environment (UAT- User acceptance testing). The Deployment phase doesn’t signal the end, but rather a notable milestone. 
It signifies the shift from a project phase to a product phase, where the software begins to fulfill its purpose.
Then based on the feedback, the product may be released as it is or
with suggested enhancements in the targeting market segment. After the product is released in the market, its maintenance is done for the
existing customer base.

	Phase 7: Maintenance -  the maintenance phase is characterized by constant assistance and improvement, which guarantees the software’s best possible 
functioning and longevity and ensures it meets customer expectations.Maintenance tasks encompass frequent software updates, implementing patches, 
and fixing bugs. User support is also a crucial component, offering help and guidance to users facing difficulties with the software.
The maintenance phase also considers long-term strategies, for instance, upgrading or replacing the software. This decision depends on the software’s lifecycle and technological progress.


3. Agile vs. Waterfall Models:
Compare and contrast the Agile and Waterfall models of software development. 
What are the key differences, and in what scenarios might each be preferred?

Waterfall Model
	Waterfall model is the Sequential development model. The Waterfall Model was the first Process Model to be introduced. It is also referred to as a linear-sequential life cycle model. It is very
simple to understand and use. In a waterfall model, each phase must be completed before the next phase can begin and there is no overlapping
in the phases. The waterfall Model illustrates the software development process in a linear sequential flow. This means that any phase in the development
process begins only if the previous phase is complete. In this waterfall model, the phases do not overlap. Each phase schedule for the tasks to be completed within a specified time period. 
The documentation and testing happens at the end of each phase, which helps in maintaining the quality of the project. 
Waterfall requires extensive documentation upfront, whereas Agile focuses on working software over documentation.
Waterfall Model is suitable  Ideal for projects with well-defined and stable requirements, where changes are unlikely to occur once development begins. 
It suits projects with a fixed budget and timeline.



Agile Model
	Agile methodology has an adaptive team which is able to respond to the changing requirements. 
Customer satisfaction by rapid delivery of useful software  Welcome changing requirements, even late in development. 
Working software is delivered frequently (weeks rather than months).
The most important of the principles is customer satisfaction by giving rapid and continuous delivery of small and useful software.
Agile uses adaptive approach where there is no detailed planning and there is clarity on future tasks only in respect of what features need to be developed. 
There is feature driven development and the team adapts to the changing product requirements dynamically. The product is tested very frequently, 
through the release iterations, minimizing the risk of any major failures in future.
Agile is more flexible and adaptive to changes, while Waterfall is rigid and less accommodating to changes once the project has started.
Agile typically delivers working software sooner due to its iterative nature, while Waterfall delivers the final product at the end of the project timeline.
Therefore, best suitable areas for the agile model is projects where requirements are expected to evolve, or the market conditions are uncertain. It's beneficial for 
complex projects where stakeholder involvement and feedback are crucial for success.

Agile Model methodology example
	xtreme Programming (“XP”) methodology is based around the idea of discovering “the simplest thing that will work” without putting too much weight on the long-term product view.
It is a methodology that emphasises values such as Communication, Simplicity, Feedback, Courage and Respect, and prioritises customer satisfaction over everything else. This methodology encourages 
trust by motivating developers to accept changes in customer requirements, even if they arrive during the latter stages of the development cycle.
Teamwork is extremely important in XP, since, when there is a problem, it is solved by the whole team of managers, developers or customers, 
bringing them together to promote conversation and engagement and break down barriers to communication. They all become essential pieces of the 
same puzzle, creating a fertile environment for high productivity and efficiency within teams. 
In Extreme Programming, the software is tested from day one, collecting feedback to improve development.
XP promotes activities such as pair programming, and with a strong testing component, it’s an excellent engineering methodology.

4. Requirements Engineering:
What is requirements engineering? Describe the process and its importance in the software development lifecycle.
	Requirements engineering is the systematic process of gathering, documenting, analyzing, and managing the 
needs and expectations of stakeholders for a software system. It involves identifying and documenting what the software is expected to accomplish, 
how it should behave, and what qualities it should possess. Requirements engineering aims to establish a clear and unambiguous understanding of the
 desired outcomes of the software project, serving as the foundation for all subsequent stages of development. This process ensures that the final 
software product meets the functional and non-functional requirements  of its users, aligns with business objectives, and satisfies quality attributes 
such as usability, reliability, performance, and security.

Requirements Engineering Processes:
	-Elicitation: This involves identifying and gathering requirements from various stakeholders, including clients, end-users, business analysts,
and domain experts. Techniques such as interviews, surveys, workshops, and observation are often used to elicit requirements.

	-Documentation: Once requirements are gathered, they need to be documented in a structured manner. This documentation typically includes functional 
requirements (what the system should do) and non-functional requirements (qualities the system should have, such as performance, security, 
and usability).

	-Analysis: During this phase, the gathered requirements are analyzed to ensure they are clear, complete, and consistent. 
Conflicting or ambiguous requirements are resolved, and dependencies between requirements are identified.

	-Specification: The requirements are then formally specified using appropriate documentation formats, such as use cases, user stories, 
requirement documents, or models like UML diagrams. This specification serves as a reference for the development team throughout the project.

	-Validation: Validation involves verifying that the specified requirements accurately capture the stakeholders' needs and expectations. 
This may include reviews, walkthroughs, prototyping, or simulations to ensure that the proposed solution aligns with the desired outcomes.

	-Management: Requirements are subject to change throughout the project due to evolving business needs, technological advancements, or 
stakeholder feedback. Therefore, effective requirements management involves tracking changes, maintaining traceability between requirements and 
other project artifacts, and ensuring that all stakeholders are informed of any modifications.

5. Software Design Principles:
Explain the concept of modularity in software design. 
	Modularity in software design is a fundamental principle that involves breaking down a software system into smaller, self-contained units 
or modules, each responsible for a specific set of functionalities. These modules are designed to be independent, with well-defined interfaces that 
allow them to interact with each other and with the rest of the system.modularity in software design promotes maintainability, scalability, 
reusability, and flexibility, leading to more robust, adaptable, and manageable software systems. By organizing a software system into 
modular components with well-defined interfaces, developers can build complex systems more effectively while reducing the risk of errors, 
improving code quality, and enhancing overall system architecture.

How does it improve maintainability and scalability of software systems?
	 Maintainability:

Isolation of Changes: Modularity allows changes to be localized within specific modules without affecting the entire system. 
Developers can modify or update a module without needing to understand or modify other parts of the system, reducing the risk of unintended 
side effects.

Ease of Debugging and Testing: With well-defined boundaries between modules, debugging and testing become more focused and manageable.
Developers can isolate and troubleshoot issues within individual modules, leading to faster resolution of bugs and errors.

Code Reusability: Modular design promotes code reusability, as modules can be reused across different parts of the system or in future projects. 
This reduces duplication of effort, improves consistency, and simplifies maintenance by leveraging existing, tested components.
	Scalability:

Improved Performance: Modular design enables better performance optimization by allowing developers to focus on optimizing individual modules 
rather than the entire system. Performance bottlenecks can be identified and addressed within specific modules, resulting in overall performance 
improvements.

Flexibility and Adaptability: Modular architectures are inherently flexible and adaptable to changing requirements or environments. 
As the system evolves, modules can be modified, replaced, or extended without affecting other parts of the system, making it easier to adapt to
evolving business needs or technological advancements.

6. Testing in Software Engineering:
Describe the different levels of software testing (unit testing, integration testing, system testing, acceptance testing). 

	Testing is the process of evaluating a system or its component(s) with the intent to find whether it satisfies the specified requirements or not. 
Basically, testing is executing a system in order to identify any gaps, errors, or missing requirements in contrary to the actual requirements.
According to ANSI/IEEE 1059 standard, Testing can be defined as a process of analysing a software item to detect the differences between existing
and required conditions (that is defects/errors/bugs) and to evaluate the features of the software item. 
	
Levels of testing - Testing is performed at different levels involving the complete system or parts of it throughout the life cycle of a software product.
	Unit Testing - This type of testing is performed by developers before the setup is handed over to the testing team to formally execute the 
test cases. Unit testing is performed by the respective developers on the individual units of source code assigned areas. The developers use test
data that is different from the test data of the quality assurance team. The goal of unit testing is to isolate each part of the program and 
show that individual parts are correct in terms of requirements and functionality. Also  the individual units/components are tested in a standalone manner. 
The purpose is to validate that each unit of the software performs as designed without any dependency. 
-Limitations of Unit Testing 
	Testing cannot catch each and every bug in an application. It is impossible to evaluate every execution path in every software application. 
	The same is the case with unit testing. There is a limit to the number of scenarios and test data that a developer can use to verify a source code. 
	After having exhausted all the options, there is no choice but to stop unit testing and merge the code segment with other units. 

	Integration Testing -Integration testing is defined as the testing of combined parts of an application to determine if they function 
correctly. Additionally,  is a level of the software testing process where individual units are combined and tested as a group. The purpose of this level of testing is 
to expose faults in the interaction between integrated units.
Integration testing can be done in two ways: Bottom-up integration testing and Top-down integration testing. 
-Integration Testing Method 
1 Bottom-up integration This testing begins with unit testing, followed by tests of progressively higher-level combinations of units called modules or builds.
2 Top-down integration In this testing, the highest-level modules are tested first and progressively, lower-level modules are tested thereafter. 
In a comprehensive software development environment, bottom-up testing is usually done first, followed by top-down testing. 
The process concludes with multiple tests of the complete application, preferably in scenarios designed to mimic actual situations. 

	System Testing System testing tests the system as a whole. The purpose of this test is to evaluate the system's agreement with the specified requirements 
Once all the components are integrated, the application as a whole is tested rigorously to see that it meets the specified Quality Standards. 
This type of testing is performed by a specialized testing team. 
System testing is important because of the following reasons: 
-System testing is the first step in the Software Development Life Cycle, where the application is tested as a whole. 
-The application is tested thoroughly to verify that it meets the functional and technical specifications.
-The application is tested in an environment that is very close to the production environment where the application will be deployed.
-System testing enables us to test, verify, and validate both the business requirements as well as the application architecture. 

	Regression Testing Whenever a change in a software application is made, it is quite possible that other areas within the application have been affected by this change. 
Regression testing is performed to verify that a fixed bug hasn't resulted in another functionality or business rule violation. 
The intent of regression testing is to ensure that a change, such as a bug fix should not result in another fault being uncovered in the application.
Regression testing is important because of the following reasons:
-Minimize the gaps in testing when an application with changes made has to be tested.
-Testing the new changes to verify that the changes made did not affect any other area of the application.
-Mitigates risks when regression testing is performed on the application.
-Test coverage is increased without compromising timelines.
-Increase speed to market the product. 

	Acceptance Testing This is arguably the most important type of testing, as it is conducted by the Quality Assurance Team who will gauge whether the 
application meets the intended specifications and satisfies the client’s requirement. The QA team will have a set of pre-written scenarios and 
test cases that will be used to test the application. More ideas will be shared about the application and more tests can be performed on it to gauge
its accuracy and the reasons why the project was initiated. Acceptance tests are not only intended to point out simple spelling mistakes, cosmetic 
errors, or interface gaps, but also to point out any bugs in the application that will result in system crashes or major errors in the application.
By performing acceptance tests on an application, the testing team will deduce how the application will perform in production. 
There are also legal and contractual requirements for acceptance of the system.The purpose of this test is to evaluate the system's compliance with 
the business requirements and assess whether it is acceptable for delivery. 

Why is testing crucial in software development?
	Testing plays a significant role in accomplishing and evaluating the quality of a software product. 
Software quality assessment can be divided into two broad categories: Static and Dynamic analysis.
 Static Analysis means that it is based on the examination of a number of documents, namely requirements documents, software models, design documents,
and source code, etc. Basic methods used in static analysis includes code review, inspection, walkthrough, algorithm analysis, and proof of 
correctness. It does not involve actual execution of the code under development.
 Dynamic analysis of a software system involves actual program execution in order to expose possible program failures. The behavioral and performance properties of the program are also observed. 
Programs are executed with both typical and carefully chosen input values.

One major objective of testing is to see whether the software will work properly covers the test cases to check the system will work properly with all specified operations this 
test intend to check the basic flow of use case model and it covers the positive testing scenario.
Another objective covers the test cases to fail or crash the system explicitly, to know the limit and boundaries of system, so likewise the maximum 
system capacity in terms of processing speed, memory allocations, interrupt handling, etc. can be known.
Another covers the test cases to make the system fail, so check all the alternative flows specified during the use case model and it covers the 
negative testing scenario.
Finally and most importantly,  focuses on designing of minimum test cases to cover the maximum system testing, it is near to impossible to test all 
the combination of test cases ,so the challenge of testing is to cover entire system testing with minimum number of test cases and utilize the 
resources optimally with reducing the cost associated with it. The test case generation is one of the most important task in testing. 

7. Version Control Systems:
What are version control systems, and why are they important in software development?
	Version Control Systems (VCSs) enable the acceleration and simplification of the software development process, and enable new workflows. 
They keep track of files and their history and have a model for concurrent access. The basic principles of Version Control systems include;
Keep a record and history of changes, give public access to the informaion, to maintain different versions from the same data set.
Version control (or revision control, or source control) is all about managing multiple versions of documents, programs, web sites, etc. 
There are two different approaches to VCSs:
-The centralized model with the centralized Version Control Systems (CVCSs). Examples include CVS and Subversion
-The distributed model with the distributed Version Control Systems (DVCSs). Examples include Mercurial and Git

A good version control system: 
 • Will store manyversionsofyourfiles. 
 • Will let you “revert” a file (or a part ofa file) to an olderversion.
 • Will track the order ofdifferentversions.
 • Will ensure each “version” is neither too big nor too small.
A great version control system:
 • Will let you collaborate on files with other people.
 • Will help you combine “branched” versions of the files produced bydifferent people working independently.


Importance of Version Control Systems:
	Collaboration: Version control systems significantly simplifies collaboration among developers. Multiple team members can work on the same project simultaneously,
and any modifications are automatically synced with the central repository. This facilitates seamless teamwork and minimizes conflicts that arise 
from working on shared codebases.

	Code Consistency: With version control systems, developers can maintain a consistent codebase. Every change made to the code is stored 
in the system, ensuring that the entire team is working on the same version. This eliminates the hassle of dealing with multiple copies and allows 
for efficient collaboration.

	Record Keeping: Version control systems maintain a detailed history of changes made to the codebase. Each commit is documented, including 
the author, timestamp, and a description of the modifications. This audit trail is invaluable for understanding the evolution of the code and for 
identifying the root cause of issues.

	Error Recovery: Version control systems provides a safety net for developers by offering the ability to revert to previous versions of the code. 
If a mistake is made or a bug is introduced, developers can easily roll back to a known working state. This saves valuable time and ensures that 
the project remains on track.



Give examples of popular version control systems and their features
  GitHub
GitHub helps software teams to collaborate and maintain the entire history of code changes.
You can track changes in code, turn back the clock to undo errors and share your efforts with other team members.
It is a repository to host Git projects. 
Git is an open source version control system that features local branching, multiple workflows, and convenient staging areas.
Git version control is an easy to learn option and offers faster operation speed.

  Mercurial
Mercurial is known for its efficiency in handling projects of all sizes. 
It is a free and distributed control management service that provides a simple and intuitive user interface.
Developers and enterprises adore Mercurial for its backup system, search functionality, project tracking and management, data import and export, 
and data migration tool. It also features workflow management, history tracking, security management, access controls and more.

  AWS CodeCommit
AWS CodeCommit is a managed version control system that hosts secure and scalable private Git repositories.
It seamlessly connects with other products from Amazon Web Services (AWS) and hosts the code in secured AWS environments.
Hence, it is a good fit for the existing users of AWS.
AWS integration also provides access to several useful plugins from AWS partners, which helps in software development.

  GitLab
GitLab comes with a lot of handy features like an integrated project, a project website, etc. 
Using the continuous integration (CI) capabilities of GitLab, you can automatically test and deliver the code.
You can access all the aspects of a project, view code, pull requests, and combine the conflict resolution.

8. Software Project Management:
Discuss the role of a software project manager. 
	Software project managers are responsible for preparation and implementation of the software projects. 
Software project manager’s responsibilities are to analyze project constraints, establish the project objectives, coordinate the project’s internal 
and external teams, construct the project timelines and monitor the project’s key performance indicators. Here are the responsibilities:
	Interpersonal responsibilities which include:
 -leading the project team,
 -liaising with initiators, senior management and suppliers;
 -being the 'figurehead', i.e. setting the example to the project team and representing the project on formal occasions. 
	Informational responsibilities, which include:
 -monitoring the performance of staff and the implementation of the project plan.
 -disseminating information about tasks to the project team.
 -disseminating information about project status to initiators and senior management.
 -acting as the spokesman for the project team. 
	Decisional responsibilities, which include.
 -allocating resources according to the project plan, and adjusting those allocations when circumstances dictate (i.e. the project manager has 
 responsibility for the budget)
 -negotiating with the initiator about the optimum interpretation of contractual obligations, with the

What are some key responsibilities and challenges faced in managing software projects?
Key responsibilities of a project manager:
	-Planning Everything from Execution to Delivery
A software project manager will always have a plan ready to maximize output while minimizing input. 
Project managers are tasked with determining the most efficient means of achieving the desired outcomes for their clients and other stakeholders as 
soon as possible. The project manager should choose the method, such as Agile, Waterfall or whichever suitable.
This software development management function entails;
 Dividing the work into manageable chunks.
 Using a hierarchical breakdown of the tasks at hand.
 Establishing a reasonable timetable for the completion of specific outputs.
 Outlining key points.
 Bringing to light the interdependencies inside the project. 

	-Oversee the Software Development Team.
The software development team includes; Business analysts, Web designers,Software developers,Content creators,Graphic designers,Sales and advertising
teams, Marketing teams among many others. A project manager’s ability to get people working together toward the same goal is crucial. 
This requires an awareness of the many roles within the software development team, an effective organizational framework, and frequent updates on 
the program’s status and your own personal goals and objectives. Not being well-organized will make it impossible to do any of these.
The project manager requires you to coordinate efforts across departments to set goals, define tasks, and ensure that stakeholders 
(whether internal or external) are held to deadlines and expectations. The PM will execute all phases of the project lifecycle, including scope 
management, timeline management and knowledge management. Even if new project management tools make it more convenient, it is still the project 
manager’s responsibility to bring order to a heterogeneous team in order to streamline project activity.

	-Delegating Work Effectively
Every project manager must practice and master this form of leadership, and doing so successfully is ultimately the manager’s job as a part of risk 
management. A manager shouldn’t exploit their position to make their employees feel bad about themselves. Team members can be more efficient and 
productive if they are given higher-priority duties. Managers should assess their staff’ abilities and assign work accordingly. 

	-Monitoring Progress and Tracking Roadblocks
A project manager’s responsibility after the project has begun is to monitor progress and ensure that work is proceeding as planned. 
During the project’s midsection, progress is accomplished via a variety of methods, including periodic reviews, briefings, and spontaneous updates. 
If the project managers pick the right management system, they’ll have less work to do.

	-Managing the Deployment Deliverables
Delivery of deliverables on schedule and within budget is another key responsibility of the project manager.Within a company or organization, 
project managers oversee the preparation and carrying out of specific projects. They should be able to take charge, communicate well, and pay close 
attention  to detail.

Challenges faced in managing software projects:
	-Misalignment between goals and business objectives - Unfortunately, too many organizations will fail to invest the time and effort required
for thorough project planning. While a project manager might not always be responsible for poor project planning, they are responsible for completing
 the entire project. 
The most effective way for project managers to ensure project goals and business objectives are aligned is to involve themselves in the project 
planning phase. But first, project managers should develop a business case for the project.Developing a business case during the project planning 
phase reduces the chances of pursuing a project that is not aligned with the organization’s overall objectives. 

	-Lack of Accountability - All team members have a vital role to play in the success of a project, but if they are not accountable, it will 
be challenging to finish the project with any degree of success. Project managers are tasked with holding team members accountable and completing 
the project on time and within budget. Project managers that want to establish clear responsibilities for team members need to effectively 
communicate responsibilities and expectations at the project’s outset. In addition, project managers must hold team members accountable to the 
organization’s standards.

	-Project Management Software - Using a project management tool that meets the team’s needs can be challenging for project managers. 
You can use project management software with a client portal if you want to enhance collaboration and communication between your team and clients. 
Since so many software solutions are available, choosing the right project management software can be difficult. 
The best way for project managers to find the right software for their team and project is to consider what features are most important to the team. 
Meeting with team members to discuss software features most important to their tasks can be helpful.
However, project managers will likely have to weigh which features are most critical and which can be sacrificed while reviewing all options. 
Also note that the software options with every feature and function might not be the best tool for your project. 

	-Poor Planning and Unrealistic Deadlines -  Project managers set unrealistic deadlines for several reasons, but the most common reasons for
 doing so are: over optimistic, pressure from stakeholders, poor estimation skills among others.
The most effective way to set deadlines that work for everyone is to have discussions with team members regarding the task, the amount of time it 
will take to review, and stakeholder expectations. 
Developing a reasonable schedule can be one of the most time-consuming tasks a project manager faces, 
but at the same time solid and realistic deadlines make the entire project easier to manage. 

9.Software Maintenance:
Define software maintenance and explain the different types of maintenance activities.
	Software maintenance is the process of modification or making changes in the system after delivery to overcome errors and faults in the 
system that were not uncovered during the early stages of the development cycle. 
The IEEE Standard for Software Maintenance (IEEE 1219) gave the definition for software maintenance as “The process of modifying a software system 
or component after delivery to correct faults, improves performance or other attributes, or adapt to a changed environment.” 

Also IEEE provides a framework for sequential maintenance process activities;
-Identification & Tracing - It involves activities pertaining to identification of requirement of modification or maintenance. It is generated by 
user or system may itself report via logs or error messages.Here, the maintenance type is classified also. 
-Analysis - The modification is analyzed for its impact on the system including safety and security implications. If probable impact is severe, 
alternative solution is looked for. A set of required modifications is then materialized into requirement specifications. The cost of 
modification/maintenance is analyzed and estimation is concluded. 
-Design - New modules, which need to be replaced or modified, are designed against requirement specifications set in the previous stage. Test cases 
are created for validation and verification.
-Implementation - The new modules are coded with the help of structured design created in the design step.Every programmer is expected to do unit 
testing in parallel. 
-System Testing - Integration testing is done among newly created modules. Integration testing is also carried out between new modules and the 
system. Finally the system is tested as a whole, following regressive testing procedures.
-Acceptance Testing - After testing the system internally, it is tested for acceptance with the help of users. If at this state, user complaints 
some issues they are addressed or noted to address in next iteration.
-Delivery - After acceptance test, the system is deployed all over the organization either by small update package or fresh installation of the 
system. The final testing takes place at client end after the software is delivered. Training facility is provided if required, in addition to the 
hard copy of user manual.
-Maintenance management - Configuration management is an essential part of system maintenance. It is aided with version control tools to control 
versions, semi-version or patch management. 

Why is maintenance an essential part of the software lifecycle?
	-Improves reliability and stability
One of the primary benefits of software maintenance is that it improves the reliability and stability of software products. 
Through regular maintenance, bugs, and errors can be identified and fixed, preventing them from causing system failures or other issues that can 
negatively impact user experience. This results in a more stable and reliable software product that users can depend on.
	-Adapt to changing technology trends
As technology persistently progresses, it is crucial to regularly update and maintain software in order to sustain its significance and 
competitiveness in the industry. Software maintenance allows developers to adapt to changing technology trends by adding new features and 
functionality, improving compatibility with new hardware and software, and optimizing performance for new platforms and devices. 
This helps to ensure that the software remains useful and valuable for users, and can help to attract and retain customers over the long term.
	-Improves security
Security threats are constantly evolving, and software systems must be able to adapt to these changes. Software maintenance is critical in ensuring 
that the software remains secure and protected against potential vulnerabilities. Regular security updates and patches can help to address security 
flaws, while security audits and assessments can identify potential areas of weakness that require attention.
	-Improves performance
Software maintenance helps to improve the performance of the software by addressing issues that affect speed and efficiency. Performance issues can
arise due to a variety of reasons, including inefficient code, memory leaks, and hardware limitations. By regularly monitoring and optimizing the 
software, developers can identify and fix these issues, resulting in faster and more efficient software. Optimized software is typically received 
better by users because they spend less time waiting around, which keeps them happy, as well as reduces the likelihood of downtime and disruptions 
to business operations.

10. Ethical Considerations in Software Engineering:
What are some ethical issues that software engineers might face? 
	- Right to privacy versus the need  to protect vulnerable user groups - There are increasing concerns over the use of the Internet to organize 
criminal activities such as the grooming of children by pedophiles, terrorists recruiting impressionable youths, and online credit card fraud, among 
many others. This requires software-based solutions to aid police and other law enforcement agencies.. Software engineers developing such systems 
must balance the need to safeguard the privacy of the individual against the need to protect vulnerable user groups—for example, protecting children 
from predatory advances.
	-Freedom of choice versus protection from harm - The ubiquitous access to the Internet has also provided opportunities for businesses and
the general public to offer new services that should be designed to be attractive to the consumer. However, there are concerns that the features of 
online gambling sites, for instance, that make the gaming experience enjoyable are also the ones likely to cause harm to those at risk of gambling 
addiction. Software designs for such systems must account for both an individual’s freedom to make choices and the notion of common good.



How can software engineers ensure they adhere to ethical standards in their work?
	One way is to incorporate ethics-aware practices in existing software engineering methodologies and processes. 
Although existing software engineering methodologies and processes account for nonfunctional properties, ethical considerations are not at the 
forefront of such analyses. Incorporation of ethics-aware practices, therefore, requires software and business process improvement frameworks to 
facilitate an incremental evolution not only of the methodologies and processes but also of organizational practices and codes of conduct.

	Secondly, is to train software engineers in ethics-aware software design. There is an international shortage of personnel trained in the 
ethical considerations that modern IT systems raise. Training of software engineers in ethics-aware software design is, therefore, essential to 
overcome this shortage. Any such training requires both adaptation of existing professional training programs and certifications.

References
1.Davidson T. (2023). Importance of Software Maintenance in Software Engineering 
(https://cleancommit.io/blog/importance-of-software-maintenance-in-software-engineering/)
2. Kazmi R. (2024). Common Project Manager Challenges in Software Development. (https://www.koombea.com/blog/project-manager-challenges/).
3. Kavidar N. (2018). Top 10 Version Control Systems. (https://hackernoon.com/top-10-version-control-systems-4d314cf7adea)
4. Nirali H. (2019). Role of Testing in Software Development Life Cycle.   International Journal of Computer Sciences and Engineering.
5. Rashid A.,Weckert J., & Lucas R.(2009). SOFTWARE  ENGINEERING ETHICS IN  A DIGITAL WORLD. IEEE Computer Society.
6. Sommerville, I. (2011) Software Engineering. 9th edition, Pearson.
7. TRINITY INSTITUTE OF TECHNOLOGY AND RESEARCH BHOPAL. Software Engineering & Project Management. Prepared by Urmila Mahor.

