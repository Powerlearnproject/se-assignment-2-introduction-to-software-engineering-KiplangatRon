Assignment: Introduction to Software Engineering Instructions: 
Answer the following questions based on your understanding of software engineering concepts. 
Provide detailed explanations and examples where appropriate.

1. Define Software Engineering:
What is software engineering, and how does it differ from traditional programming?
	Software engineering is an engineering discipline that is concerned with all aspects of software production from initial conception to
operation and maintenance.Software engineering is not just concerned with the technical processes of software development. It also includes activities
such as software project management and the development of tools, methods,and theories to support software development. In its engineering aspect software 
engineers apply theories, methods, and tools where these are appropriate. However, they use them selectively and always try to discover solutions to 
problems even when there are no applicable theories and methods. Software engineers also recognize that they must work within organizational and 
financial constraints, and they must look for solutions within these constraints.

2.  Software Development Life Cycle (SDLC):
Explain the various phases of the Software Development Life Cycle. 
	Software Development Life Cycle (SDLC): A Software Development Life Cycle or SDLC model is a simplified representation of a software process. 
It is a process used by the software industry to design, develop and test high quality software. Each process model represents a process from a
particular perspective and thus only provides partial information about that process.It consists of a detailed plan describing how to develop, 
maintain,replace and alter or enhance specific software. 

Provide a brief description of each phase.
	Phase 1: Planning and Requirement Analysis - Requirement analysis is the most important and fundamental stage in SDLC. It is performed by 
the senior members of the team with inputs from the customer, the sales department, market surveys and domain experts in
the industry. This information is then used to plan the basic project approach and to conduct product feasibility study in the economical,operational 
and technical areas.Planning for the quality assurance requirements and identification of the risks associated with the project is also done in the planning stage. 
The outcome of the technical feasibility study is to define the various technical approaches that can be followed to implement the project 
successfully with minimum risks.

	Phase 2: Defining Requirements - the next step is to clearly define and document the product requirements and get them approved from
the customer or the market analysts and it is done through an SRS (Software Requirement Specification) document which consists of all the product
requirements to be designed and developed during the project life cycle.

	Phase 3: Designing the Product Architecture - The Design phase is all about building the framework. The development team is responsible 
for software engineering and outlines the software’s functionality and aesthetic. This ultimately results in the software product.
The emphasis lies on outlining the software’s structure, navigation, user interfaces, and database design. This phase ensures that the software 
is user-friendly and performs its tasks efficiently.Software Requirement Specification (SRS) is the reference for product architects to come out with the 
best architecture for the product to be developed. Based on the requirements specified in SRS,usually more than one design approach for the product
architecture is proposed and documented in a DDS - Design Document Specification. This DDS is reviewed by all the important stakeholders and based 
on various parameters as risk assessment, product robustness, design modularity, budget and time constraints, the best design approach is selected for the product.
A design approach clearly defines all the architectural modules of the product along with its communication and data flow representation with the external and
third party modules (if any). The internal design of all the modules of the proposed architecture should be clearly defined with the smallest
of the details in DDS. 
The Design phase is the link between the software’s purpose (established in the Planning and Requirements Analysis phases) and its execution 
(defined in the coding or the building the product phase). It’s an essential step in creating software that works efficiently and provides an excellent user experience.

	Phase 4: Building or Developing the Product - In this phase of SDLC the actual development starts and the product is built. The programming 
code is generated as per DDS during this stage. If the design is performed in a detailed and organized manner, code generation can be accomplished 
without much hassle. Another key aspect of this phase is regular code reviews. Team members carefully examine each other’s work to identify any bugs or inconsistencies.
These meticulous assessments uphold high code standards, ensuring the software’s reliability and robustness. This phase also includes preliminary internal testing to 
confirm the software’s basic functionality.
Developers must follow the coding guidelines defined by their organization and programming tools like compilers, interpreters, debuggers, etc. are used to
generate the code. Different high level programming languages such as C, C++, Pascal, Java and PHP are used for coding. 
The programming language is chosen with respect to the type of software being developed.

	Phase 5: Testing the Product - This phase is usually a subset of all the stages as in the modern SDLC models, the testing activities are mostly involved in all the stages of
SDLC.However, this stage refers to the testing only stage of the product where product defects are reported, tracked, fixed and retested, until
the product reaches the quality standards defined in the SRS.Software testing involves a thorough examination of the software for any bugs or 
glitches that might have slipped through during coding. The aim is to ensure flawless software operation before it reaches the end-users and even identify opportunities for enhancement.
The testing process begins by setting clear parameters in line with the software’s requirements. This includes identifying the necessary software conditions, 
and outlining diverse scenarios to examine these conditions. This phase aids in creating an efficient testing strategy.

	Phase 6: Deployment in the Market and Maintenance - After crafting a product with precision, it’s time to present it to the users by pushing to the production environment. 
The Deployment phase involves rolling out the meticulously tested and fine-tuned software to its end-users.Sometimes product deployment
happens in stages as per the business strategy of that organization. The product may first be released in a limited segment and tested in the
real business environment (UAT- User acceptance testing). The Deployment phase doesn’t signal the end, but rather a notable milestone. 
It signifies the shift from a project phase to a product phase, where the software begins to fulfill its purpose.
Then based on the feedback, the product may be released as it is or
with suggested enhancements in the targeting market segment. After the product is released in the market, its maintenance is done for the
existing customer base.

	Phase 7: Maintenance -  the maintenance phase is characterized by constant assistance and improvement, which guarantees the software’s best possible 
functioning and longevity and ensures it meets customer expectations.Maintenance tasks encompass frequent software updates, implementing patches, 
and fixing bugs. User support is also a crucial component, offering help and guidance to users facing difficulties with the software.
The maintenance phase also considers long-term strategies, for instance, upgrading or replacing the software. This decision depends on the software’s lifecycle and technological progress.


3. Agile vs. Waterfall Models:
Compare and contrast the Agile and Waterfall models of software development. 
What are the key differences, and in what scenarios might each be preferred?

Waterfall Model
	Waterfall model is the Sequential development model. The Waterfall Model was the first Process Model to be introduced. It is also referred to as a linear-sequential life cycle model. It is very
simple to understand and use. In a waterfall model, each phase must be completed before the next phase can begin and there is no overlapping
in the phases. The waterfall Model illustrates the software development process in a linear sequential flow. This means that any phase in the development
process begins only if the previous phase is complete. In this waterfall model, the phases do not overlap. Each phase schedule for the tasks to be completed within a specified time period. 
The documentation and testing happens at the end of each phase, which helps in maintaining the quality of the project. 
Waterfall requires extensive documentation upfront, whereas Agile focuses on working software over documentation.
Waterfall Model is suitable  Ideal for projects with well-defined and stable requirements, where changes are unlikely to occur once development begins. 
It suits projects with a fixed budget and timeline.



Agile Model
	Agile methodology has an adaptive team which is able to respond to the changing requirements. 
Customer satisfaction by rapid delivery of useful software  Welcome changing requirements, even late in development. 
Working software is delivered frequently (weeks rather than months).
The most important of the principles is customer satisfaction by giving rapid and continuous delivery of small and useful software.
Agile uses adaptive approach where there is no detailed planning and there is clarity on future tasks only in respect of what features need to be developed. 
There is feature driven development and the team adapts to the changing product requirements dynamically. The product is tested very frequently, 
through the release iterations, minimizing the risk of any major failures in future.
Agile is more flexible and adaptive to changes, while Waterfall is rigid and less accommodating to changes once the project has started.
Agile typically delivers working software sooner due to its iterative nature, while Waterfall delivers the final product at the end of the project timeline.
Therefore, best suitable areas for the agile model is projects where requirements are expected to evolve, or the market conditions are uncertain. It's beneficial for 
complex projects where stakeholder involvement and feedback are crucial for success.

Agile Model methodology example
	xtreme Programming (“XP”) methodology is based around the idea of discovering “the simplest thing that will work” without putting too much weight on the long-term product view.
It is a methodology that emphasises values such as Communication, Simplicity, Feedback, Courage and Respect, and prioritises customer satisfaction over everything else. This methodology encourages 
trust by motivating developers to accept changes in customer requirements, even if they arrive during the latter stages of the development cycle.
Teamwork is extremely important in XP, since, when there is a problem, it is solved by the whole team of managers, developers or customers, 
bringing them together to promote conversation and engagement and break down barriers to communication. They all become essential pieces of the 
same puzzle, creating a fertile environment for high productivity and efficiency within teams. 
In Extreme Programming, the software is tested from day one, collecting feedback to improve development.
XP promotes activities such as pair programming, and with a strong testing component, it’s an excellent engineering methodology.

4. Requirements Engineering:
What is requirements engineering? Describe the process and its importance in the software development lifecycle.
	Requirements engineering is the systematic process of gathering, documenting, analyzing, and managing the 
needs and expectations of stakeholders for a software system. It involves identifying and documenting what the software is expected to accomplish, 
how it should behave, and what qualities it should possess. Requirements engineering aims to establish a clear and unambiguous understanding of the
 desired outcomes of the software project, serving as the foundation for all subsequent stages of development. This process ensures that the final 
software product meets the functional and non-functional requirements  of its users, aligns with business objectives, and satisfies quality attributes 
such as usability, reliability, performance, and security.

Requirements Engineering Processes:
	-Elicitation: This involves identifying and gathering requirements from various stakeholders, including clients, end-users, business analysts,
and domain experts. Techniques such as interviews, surveys, workshops, and observation are often used to elicit requirements.

	-Documentation: Once requirements are gathered, they need to be documented in a structured manner. This documentation typically includes functional 
requirements (what the system should do) and non-functional requirements (qualities the system should have, such as performance, security, 
and usability).

	-Analysis: During this phase, the gathered requirements are analyzed to ensure they are clear, complete, and consistent. 
Conflicting or ambiguous requirements are resolved, and dependencies between requirements are identified.

	-Specification: The requirements are then formally specified using appropriate documentation formats, such as use cases, user stories, 
requirement documents, or models like UML diagrams. This specification serves as a reference for the development team throughout the project.

	-Validation: Validation involves verifying that the specified requirements accurately capture the stakeholders' needs and expectations. 
This may include reviews, walkthroughs, prototyping, or simulations to ensure that the proposed solution aligns with the desired outcomes.

	-Management: Requirements are subject to change throughout the project due to evolving business needs, technological advancements, or 
stakeholder feedback. Therefore, effective requirements management involves tracking changes, maintaining traceability between requirements and 
other project artifacts, and ensuring that all stakeholders are informed of any modifications.

